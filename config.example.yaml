# EdgeQuota Configuration Example
# Copy to /etc/edgequota/config.yaml or set EDGEQUOTA_CONFIG_FILE.

server:
  address: ":8080"
  read_timeout: "30s"
  write_timeout: "30s"
  idle_timeout: "120s"
  drain_timeout: "30s"
  # max_websocket_conns_per_key: 100   # Max concurrent WS connections per rate-limit key (0=unlimited)
  # Optional TLS termination. Required for HTTP/3.
  # Certificates are hot-reloaded when the file changes on disk.
  # tls:
  #   enabled: true
  #   cert_file: "/etc/edgequota/tls/cert.pem"
  #   key_file: "/etc/edgequota/tls/key.pem"
  #   http3_enabled: true        # Serve HTTP/3 (QUIC) on the same address over UDP
  #   http3_advertise_port: 443  # External port for Alt-Svc header (0 = use listen port)
  #   min_version: "1.2"    # Minimum TLS version: "1.2" (default) or "1.3"

admin:
  address: ":9090"
  read_timeout: "5s"
  write_timeout: "10s"
  idle_timeout: "30s"

backend:
  # Default backend URL. Required unless rate_limit.external is enabled, in
  # which case the external service can provide per-tenant backend URLs via the
  # "backend_url" field in the GetLimits response. When both are set, the
  # external service's backend_url takes precedence for that request.
  url: "http://my-backend:8080"
  timeout: "30s"
  max_idle_conns: 100
  idle_conn_timeout: "90s"
  # tls_insecure_skip_verify: false

  # ── Backend URL Policy ─────────────────────────────────────────────
  # Controls which dynamic backend URLs (from the external rate-limit service)
  # are allowed. IMPORTANT: When using backend_url overrides from the external
  # RL service, set allowed_hosts to restrict where traffic can be routed.
  # If the external RL service is compromised, any allowlist it returns is
  # equally untrustworthy — the ONLY defensible enforcement point is this
  # static configuration. The allowlist is optional but strongly recommended.
  #
  # url_policy:
  #   allowed_schemes:         # Restrict URL scheme. Default: ["http", "https"].
  #     - "http"
  #     - "https"
  #   deny_private_networks: true  # Block RFC 1918, loopback, link-local, cloud metadata IPs. Default: true.
  #   allowed_hosts:           # Optional host allowlist. When non-empty, only these hosts are permitted.
  #     - "backend-a.internal"
  #     - "backend-b.internal"

  # Low-level HTTP transport tuning. All values have sensible defaults.
  transport:
    # Backend protocol for non-gRPC traffic. gRPC always uses HTTP/2.
    #   "auto" (default) — probe the backend via TLS ALPN at startup:
    #       cleartext (http://) -> h1
    #       HTTPS with h2 ALPN  -> h2
    #       HTTPS without h2    -> h1
    #     When no static backend_url is set (dynamic backends from ext RL),
    #     "auto" defaults to h1 since the target varies per-request and
    #     can't be probed at startup.
    #   "h1"  — force HTTP/1.1
    #   "h2"  — force HTTP/2 (h2c for http://, h2 over TLS for https://)
    #   "h3"  — force HTTP/3 (QUIC); requires an https:// backend
    #
    # ⚠ HTTP/3 backend prerequisite — UDP buffer sizes
    #
    #   quic-go (the QUIC library) requires the kernel UDP receive buffer
    #   (net.core.rmem_max) to be at least 7168 KiB (7340032 bytes). When
    #   this limit is too low, QUIC connections time out with:
    #
    #     "failed to sufficiently increase receive buffer size
    #      (was: 208 kiB, wanted: 7168 kiB, got: 416 kiB)"
    #
    #   This happens because containers running with restricted security
    #   contexts (readOnlyRootFilesystem, drop ALL capabilities) can only
    #   double the default buffer — well below the 7 MiB quic-go needs.
    #   The result is packet loss and 5-second connection timeouts on every
    #   request to the HTTPS backend, producing 502 errors.
    #
    #   To fix this, BOTH of the following must be configured:
    #
    #   1. Raise the kernel limit — so the setsockopt(SO_RCVBUF) call
    #      succeeds. In Kubernetes, the recommended approach is a
    #      privileged init container that runs sysctl before EdgeQuota
    #      starts (see the Helm chart initContainers example). Alternative
    #      approaches: pod-level securityContext.sysctls (requires kubelet
    #      --allowed-unsafe-sysctls), or node-level tuning via DaemonSet
    #      / cloud-init.
    #
    #   2. Set the buffer size config below — so EdgeQuota creates the
    #      QUIC UDP socket with the desired buffer sizes explicitly,
    #      rather than relying on quic-go's internal attempt.
    #
    #   On a plain Linux host, you can set the kernel limit directly:
    #     sysctl -w net.core.rmem_max=7500000
    #     sysctl -w net.core.wmem_max=7500000
    #
    # This value can be overridden per-request by the external rate-limit
    # service. When the GetLimitsResponse includes a non-empty
    # "backend_protocol" field ("h1", "h2", or "h3"), it takes precedence
    # over this static setting for that request only. gRPC traffic always
    # uses h2 regardless.
    backend_protocol: "auto"
    dial_timeout: "30s"             # TCP dial timeout for backend connections
    dial_keep_alive: "30s"          # TCP keep-alive interval
    tls_handshake_timeout: "10s"    # TLS handshake timeout
    expect_continue_timeout: "1s"   # Expect: 100-continue timeout
    h2_read_idle_timeout: "30s"     # HTTP/2 read idle timeout (gRPC)
    h2_ping_timeout: "15s"          # HTTP/2 ping timeout (gRPC)
    websocket_dial_timeout: "10s"   # WebSocket backend dial timeout

    # ── HTTP/3 (QUIC) UDP buffer sizes ────────────────────────────────
    # These settings control the SO_RCVBUF and SO_SNDBUF sizes on the
    # UDP socket used for HTTP/3 backend connections. They only take
    # effect when backend_protocol is "h3" (or when a per-request
    # override selects h3) and the backend is HTTPS.
    #
    # quic-go requires a receive buffer of at least ~7 MiB (7340032
    # bytes) for reliable QUIC operation. The kernel must also allow
    # this size — the setsockopt(SO_RCVBUF) call is capped by
    # net.core.rmem_max (and SO_SNDBUF by net.core.wmem_max). If the
    # kernel limit is lower than the value configured here, the actual
    # buffer will be silently capped at the kernel limit.
    #
    # The recommended value is 7500000 (~7.15 MiB), matching the
    # quic-go wiki recommendation. Set to 0 to let quic-go manage
    # buffers internally (it will attempt 7 MiB and log a warning if
    # the kernel caps it lower).
    #
    # h3_udp_receive_buffer_size: 7500000
    # h3_udp_send_buffer_size: 7500000

# ─── External Authentication ──────────────────────────────────────────
# Forwards every incoming request to an external auth service BEFORE rate
# limiting. The auth service decides allow/deny and can inject response
# headers and status codes.
#
# Exactly one of auth.http or auth.grpc must be configured when enabled.

# Example A — HTTP auth (most common):
# auth:
#   enabled: true
#   timeout: "5s"
#   failure_policy: "failclosed"     # failclosed (default) | failopen
#   propagate_request_body: false    # Include request body in auth check (default: false)
#   max_auth_body_size: 65536        # Max body bytes sent to auth service (default: 64 KiB)
#   http:
#     url: "http://auth-service:8080/check"
#     forward_original_headers: false # Also send headers as X-Original-*
#   header_filter:
#     deny_list:                      # Headers never forwarded to auth service
#       - "Cookie"                    # (Authorization, Cookie, etc. are forwarded
#       - "Set-Cookie"               #  by default unless explicitly denied)
#     # allow_list: []               # Exclusive: only forward these headers
#                                    #  (deny_list is ignored when allow_list is set)

# Example B — gRPC auth (uses edgequota.auth.v1.AuthService/Check):
# auth:
#   enabled: true
#   timeout: "5s"
#   failure_policy: "failclosed"
#   grpc:
#     address: "auth-service:50051"
#     tls:
#       enabled: true
#       ca_file: "/etc/edgequota/tls/auth-ca.pem"
#       server_name: ""  # Override TLS server name verification. Empty = use hostname from address.

# ─── Rate Limiting ────────────────────────────────────────────────────
rate_limit:
  average: 100          # Requests per period (0 = disabled).
  burst: 50             # Maximum burst capacity.
  period: "1s"
  failure_policy: "passThrough"  # passThrough | failClosed | inMemoryFallback
  # failure_code: 429   # HTTP status for failClosed rejections (must be 4xx/5xx).
  # min_ttl: ""         # Optional floor for Redis key TTL (e.g. "10s"). Reduces EXPIRE churn.
  key_strategy:
    type: "clientIP"    # clientIP | header | composite
    # header_name: "X-Tenant-Id"
    # path_prefix: false
    # trusted_proxies:   # CIDRs whose X-Forwarded-For / X-Real-IP are trusted.
    #   - "10.0.0.0/8"  # When empty (default), only RemoteAddr is used.
    # trusted_ip_depth: 0  # Which XFF entry to use: 0=leftmost, N=Nth from right.

  # ─── External Rate Limit Service (optional) ───────────────────────
  # Queries an external service for per-request rate limits. Enables
  # multi-tenant scenarios where different tenants have different quotas
  # stored in a backend database. Static config values (average/burst/period)
  # are used as fallback when the external service is unreachable.
  #
  # Exactly one of external.http or external.grpc must be configured.

  # Example A — HTTP external limits service:
  # external:
  #   enabled: true
  #   timeout: "5s"
  #   cache_ttl: "60s"                # Default cache TTL when response has no cache hints
  #   max_concurrent_requests: 50     # Semaphore cap on concurrent external calls
  #   http:
  #     url: "http://limits-service:8080/limits"
  #   header_filter:
  #     allow_list:                   # Only forward these headers to the limits service
  #       - "X-Tenant-Id"
  #       - "X-Plan"

  # Example B — gRPC external limits service
  #             (uses edgequota.ratelimit.v1.RateLimitService/GetLimits):
  # external:
  #   enabled: true
  #   timeout: "5s"
  #   cache_ttl: "60s"
  #   max_concurrent_requests: 50
  #   grpc:
  #     address: "limits-service:50052"
#     tls:
#       enabled: true
#       ca_file: "/etc/edgequota/tls/limits-ca.pem"
#       server_name: ""  # Override TLS server name verification. Empty = use hostname from address.

# ─── Redis ────────────────────────────────────────────────────────────
redis:
  endpoints:
    - "redis:6379"
  mode: "single"        # single | replication | sentinel | cluster
  pool_size: 10
  dial_timeout: "5s"
  read_timeout: "3s"
  write_timeout: "3s"

# Optional dedicated Redis for external rate-limit response caches.
# If omitted, the main redis connection above is reused.
# cache_redis:
#   endpoints:
#     - "cache-primary:6379"
#     - "cache-replica-1:6379"
#   mode: "replication"
#   pool_size: 20

logging:
  level: "info"
  format: "json"
  access_log_enabled: true

# Optional OpenTelemetry tracing.
# tracing:
#   enabled: true
#   endpoint: "http://otel-collector:4318"
#   service_name: "edgequota"
#   sample_rate: 0.1
